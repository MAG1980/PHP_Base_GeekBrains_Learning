//Включение xdebug в OpenServer 
В OpenServer открыть /Дополнительно/Конфигурация/PHP7_4
1) В Zend extensions снимаем комментарий со строки zend_extension = xdebug
2) Заменяем
xdebug.mode                      = off
на
xdebug.mode                      = develop

//Объявление констант

define('PI', 3.14); //присваивание значений происходит перед выполением программы
const PI = 3.14; //присваивание значений происходит в процессе выполнения программы
PI = 3.14; //Тоже применяется. Константы принято писать заглавными символами.

При попытке вывода несуществующей константы её название будет преобразовано в строку.

//Существуют предопределённые константы (глобальные?)

__LINE__, __FILE__, __FUNCTION__, __CLASS__, __METHOD__, __DIR__, PHP_VERSION, PHP_OS, PHP_EOL (end of line) 


/ - экранирование спецсимволов
В php бинарный плюс преобразует строку к числу.
(int) - преобразование к целому числу
(float) - преобразование к числу с плавающей точкой

При сложении int и float int будет приведён к float

<?php echo - <?=
`` - избегать использования. Позволяют выполнить код на сервере - это небезопасно!!!!!!!! 
'' - не работает парсинг переменных
"" - работает парсинг переменных
"{$x}" - правильный кодстайл для переменных в тексте

<<< - оператор потокового вывода
<pre> - представляет собой предварительно отформатированный текст, который должен быть представлен точно так, как написано в HTML-файле

//Вывод нескольких строк с помощью тега <pre>
<?php
echo "<pre>";
echo <<<HERE
Несколько
строк
HERE;

//Предпочтительный способ вывода нескольких строк с помощью тега <pre> - текст должен оставаться текстом.
<?php
$x=1;
!echo "<pre>";
?>

Несколько
строк <?= $x ?>

is_null($x) - проверка на null
!error_reporting(E_ALL) - вывод всех ошибок, в т.ч. Warning
error_reporting(E_ALL & !E_NOTICE) - вывод всех ошибок за исключением Warning


$a = (int)1; //явное указание типа переменной
$a = (float)1; //явное указание типа переменной

! rand(1, 3) - выдаёт случайное число из указанного диапазона.

ДЗ:
Первый способ формирования страницы:
Вся логика работы программы располагается вверху файла, php-код до тега html.
В шаблоне HTML выводятся только готовые рассчитанные ранее величины.
Теги должны остаться в шаблоне.

Недостаток - пользователь может увидеть код.

Второй способ формирования страницы - способ активных шаблонов.
!с помощью include
В index.php, в котором содержится вся логика работы сайта, включаем строки include "site.php", содержащие шаблон, в нужных местах.

Третий способ формирования страницы - способ пассивных шаблонов.
В шаблоне переменные представляют из себя обычный текст в фигурных скобках.
<h1>{{ x }}</h1>

$content = file_get_contents("https://ya.ru") //позволяет считать содержимое сайта в переменную.

//В нашем случае нужно считать файл HTML-шаблона в переменную и вывести с помощью echo.
//Перед этим заменим все текстовые вхождения "{{ x }}" на значения переменной $x
!//с помощью функций str_replace() и file_get_contents()
$content = str_replace("{{ x }}", $x, $content)// где $content - всё содержимое шаблона. 
$content = file_get_contents("site.html");
echo $content;

Лекция №2
В ДЗ:
$login = "admin";
$pass = 123;
$auth = false;
Типичная ошибка - в операторе сравнения использовать одно =,
поэтому желательно использовать ===/

//Пример проверки авторизации
if ($login === "admin" && $pass === 123 ) {
	$auth = true;
}

//Логику авторизации можно упростить 
$auth = $login === "admin" && $pass === 123;

//Логика авторизации должна находиться в отдельном файле (auth.php),
//который нужно подключать в шаблон с помощью include.

//Сложно анализировать такой код

<?php if ($auth) {?>
	Добро пожаловать <?= $login ?>!
<?php } else { ?>
	<form action="">
	...
	</form>
<?php } ?>


//Лучше использовать альтернативный синтаксис.
//Альтернативный синтаксис принято использовать в шаблонах html.
//В чистом коде php он преимуществ не даёт.
//Признаком альтернативного синтаксиса является применение : - endif;
//Тогда фигурные скобки не нужны.

<?php if ($auth): ?>
	Добро пожаловать <?= $login ?>!
<?php  else:  ?>
	<form action="">
	...
	</form>
<?php endif; ?>

//Дурной тон - применение goto
a:
echo 1;
goto a;

!Альтернативный синтаксис позволяет заменять управляющие конструкции в шаблоне html
else:
...
endif;

//Тернарный оператор
$x = 1;
$y = ($x > 5) ? 1 : 2;

//Switch
$a = 3;
switch ($a) {
	case 1: echo 1;
			break;
			
	case "2": echo 2;
			break;
			
	default: echo "none";
}

//Альтернативный вариант switch
$a = 3;
switch (true) {
	case $a == 1: echo 1;
			break;
			
	case $a == "2": echo 2;
			break;
			
	default: echo "none";			
}
//Кодстайл - пустые строки между case

!empty( $x ) // проверка на пустоту - выдает true даже если переменная не существует
!isset( $x ) // проверка на существование
!unset( $x ) //Освободить переменную. Она перестаёт существовать.

//В PHP $x = null означает отсутствие не значения, а самой переменной $x.
$x = null;
isset( $x ); //false


Спрособы формирования страниц
SSR - высокая нагрузка на сервере
	+ лучше работает на старых и слабых устройствах
	+ SEO: лучше доступность для поисковых систем
		
SPA + ниже нагрузка на сервер 
	- выше нагрузка на клиент
	
Для улучшения позиций сайтов в выдаче поисковых систем карточки товаров принято формировать на сервере.

Краткий тег <? использовать не желательно, т.к. это может быть запрещено настройками сервера
или из соображений безопасности.

Кодстайл - в функциях не использовать echo, за исключением функций render.
echo sayHello();
function sayHello()
{
	return "Hello world <br>";
}

!В PHP объявление функции всегда отностится к глобальной области видимости,
даже если функция объявлена внутри другой функции.

!Тело функции имеет локальную область видимости.

!Чтобы объявить глобальную переменную внутри функции необходимо использовать global
global $x;
global желательно не использовать.

!//Значения по умолчанию должны быть только справа, 
//или все параметры должны иметь значения по умолчанию.
function add($arg1, $arg2=0)
{
	return $arg1 + $arg2;
}


function add(...$arg1)
{
	return var_dump( $arg ); //Array
}


!function add(float $arg1, float $arg2=0): float | int //принимает аргументы типа float и
//возвращает результат типа float или int
{
	return $arg1 + $arg2;
}

!//Запрет на изменение типа переменных
declare( strict_types=1 );

! Переменные переменных
Иногда бывает удобно иметь переменными имена переменных.
То есть, имя переменной, которое может быть определено и изменено динамически.
Обычная переменная определяется примерно таким выражением:

<?php
$a = 'hello';
$$a = 'world';		//объявление переменной $hello, содержащей "world"
echo "$a $$a";		//hello world
echo "$a $hello";	//hello world
?>


!ссылка на переменную — это и есть адрес ячейки памяти.
Для взятия ссылки в PHP используется символ: ‘&’. 

$a = 5;
$b = &$a;
echo $b //выведет 5

Теперь в нашей ячейке, куда мы передали ссылку, находится не какое-либо значение,
а адрес другой ячейки.
И если мы обратимся к переменной, в которой содержится ссылка на другую переменную,
то произойдёт в некотором смысле, redirect(перенаправление), на соответствующую переменную:

$a = 5;
$b = &$a;
$b++;
 
echo $a; //выведет 6


//Вариант №1
$a = 1;
echo inc( $a ); //2
echo $a; 		// 1 - функция inc() не изменила значение переменной $a 
function inc($x)
{
	return ++$x;
}

//Вариант №2 (плохой). Глобальные переменные - это всегда плохо.
$a = 1;
echo inc( $a ); //2
echo $a; 		// 2 - функция inc() изменила значение переменной $a - замыкание?
function inc($x)
{
	global $x;	//Объявляю глобальную переменную внутри функции
	return ++$x;
}

!//Пример использования ссылки на переменную в функции
//Вариант №3 (хороший). Использование ссылки на переменную.
$a = 1;
echo inc( $a ); 	//2
echo $a; 			// 2 - функция inc() изменила значение переменной
function inc(&$x) 	//Создаю ссылку на глобальную переменную внутри функции
{		
	return ++$x;
}

!function_exists() // Проверка функции на существование

!Function Expression и function Declaration анонимные функцииции (присваиваемые переменной)
 в PHP работают как в JavaScript.
 Стрелочные функции поддерживаются PHP с версии 7.4
 $add = fn($x, $y) => $x + $y;
 echo $add( 2, 3 ); // 5
 
 
 !set_time_limit() //Время выполнения скрипта на сервере в сек. (есть в php.ini)
 
 !Пример рекурсивного вызова функции
 function foo( $n ) {
	echo $n--;
	if ( $n > 0 ) foo( $n );
}

 !Факториал с помощью рекурсивного вызова функции
 function factorial ($n) {
 if ( $n === 0 || $n === 1) return 1;
	return $n * factorial ( $n - 1 );
 }
 
 ! Рекурсивные функции применяются для построения меню на сайтах
 
 Домашнее задание №2
 
 1. Использовать rand()
 0 считать положительным числом.

! 5. Динамическая генерация шаблонов.
 Устаревший подход генерации шаблонов допускал include() до 5 уровней вложенности.
Это приводило к появлению "лапшекода".
Современный подход заключается в использовании функции render().

! В PHP существует переменная OUT. В процессе работы скрипта в ней конкатенируются данные,
которые будут выведены в браузер по окончанию работы скрипта.
! В переменной BUFER по умолчанию пусто.
Существует возможность перенаправить вывод данных из переменной OUT в переменную BUFER с помощью функции ob_start().
ob_get_clean() возвращает содержимое с последующей его очисткой.