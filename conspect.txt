//Включение xdebug в OpenServer
!Битовые операции

Число в двоичной (бинарной) системе исчисления представляет собой набор нулей и единиц. Самый правый бит, нулевой, называется младшим значащим битом (разрядом).
Число 5 будет выглядеть, как 00000101.

Всего в наличии 6 побитовых операторов:

$a & $b — И (получаем число в котором установлены биты, которые установлены в $a и в $b)
$a | $b — Или (получаем число в котором установлены биты, которые установлены в $a или в $b)
$a ^ $b — Исключающее или (число в котором установлены биты установленные в $a или в $b, но не в обоих одновременно)
~$a — Отрицание (инверсия, 1 меняется на 0, и наоборот)
$a << $b — Сдвиг влево (все биты в $a смещаются влево на количество позиций в $b)
$a >> $b — Сдвиг вправо (все биты в $a смещаются вправо на количество позиций в $b)

 
В OpenServer открыть /Дополнительно/Конфигурация/PHP7_4
1) В Zend extensions снимаем комментарий со строки zend_extension = xdebug
2) Заменяем
xdebug.mode                      = off
на
xdebug.mode                      = develop

//Объявление констант

define('PI', 3.14); //присваивание значений происходит перед выполением программы
const PI = 3.14; //присваивание значений происходит в процессе выполнения программы
PI = 3.14; //Тоже применяется. Константы принято писать заглавными символами.

При попытке вывода несуществующей константы её название будет преобразовано в строку.

//Существуют предопределённые константы (глобальные?)

__LINE__, __FILE__, __FUNCTION__, __CLASS__, __METHOD__, __DIR__, PHP_VERSION, PHP_OS, PHP_EOL (end of line) 


/ - экранирование спецсимволов
В php бинарный плюс преобразует строку к числу.
(int) - преобразование к целому числу
(float) - преобразование к числу с плавающей точкой

При сложении int и float int будет приведён к float

<?php echo - <?=
`` - избегать использования. Позволяют выполнить код на сервере - это небезопасно!!!!!!!! 
'' - не работает парсинг переменных
"" - работает парсинг переменных
"{$x}" - правильный кодстайл для переменных в тексте

<<< - оператор потокового вывода
<pre> - представляет собой предварительно отформатированный текст, который должен быть представлен точно так, как написано в HTML-файле

//Вывод нескольких строк с помощью тега <pre>
<?php
echo "<pre>";
echo <<<HERE
Несколько
строк
HERE;

//Предпочтительный способ вывода нескольких строк с помощью тега <pre> - текст должен оставаться текстом.
<?php
$x=1;
!echo "<pre>";
?>

Несколько
строк <?= $x ?>

is_null($x) - проверка на null
!error_reporting(E_ALL) - вывод всех ошибок, в т.ч. Warning
error_reporting(E_ALL & !E_NOTICE) - вывод всех ошибок за исключением Warning


$a = (int)1; //явное указание типа переменной
$a = (float)1; //явное указание типа переменной

! rand(1, 3) - выдаёт случайное число из указанного диапазона.

ДЗ:
Первый способ формирования страницы:
Вся логика работы программы располагается вверху файла, php-код до тега html.
В шаблоне HTML выводятся только готовые рассчитанные ранее величины.
Теги должны остаться в шаблоне.

Недостаток - пользователь может увидеть код.

Второй способ формирования страницы - способ активных шаблонов.
!с помощью include
В index.php, в котором содержится вся логика работы сайта, включаем строки include "site.php", содержащие шаблон, в нужных местах.

Третий способ формирования страницы - способ пассивных шаблонов.
В шаблоне переменные представляют из себя обычный текст в фигурных скобках.
<h1>{{ x }}</h1>

$content = file_get_contents("https://ya.ru") //позволяет считать содержимое сайта в переменную.

//В нашем случае нужно считать файл HTML-шаблона в переменную и вывести с помощью echo.
//Перед этим заменим все текстовые вхождения "{{ x }}" на значения переменной $x
!//с помощью функций str_replace() и file_get_contents()
$content = str_replace("{{ x }}", $x, $content)// где $content - всё содержимое шаблона. 
$content = file_get_contents("site.html");
echo $content;

Лекция №2
В ДЗ:
$login = "admin";
$pass = 123;
$auth = false;
Типичная ошибка - в операторе сравнения использовать одно =,
поэтому желательно использовать ===/

//Пример проверки авторизации
if ($login === "admin" && $pass === 123 ) {
	$auth = true;
}

//Логику авторизации можно упростить 
$auth = $login === "admin" && $pass === 123;

//Логика авторизации должна находиться в отдельном файле (auth.php),
//который нужно подключать в шаблон с помощью include.

//Сложно анализировать такой код

<?php if ($auth) {?>
	Добро пожаловать <?= $login ?>!
<?php } else { ?>
	<form action="">
	...
	</form>
<?php } ?>


//Лучше использовать альтернативный синтаксис.
//Альтернативный синтаксис принято использовать в шаблонах html.
//В чистом коде php он преимуществ не даёт.
//Признаком альтернативного синтаксиса является применение : - endif;
//Тогда фигурные скобки не нужны.

<?php if ($auth): ?>
	Добро пожаловать <?= $login ?>!
<?php  else:  ?>
	<form action="">
	...
	</form>
<?php endif; ?>

//Дурной тон - применение goto
a:
echo 1;
goto a;

!Альтернативный синтаксис позволяет заменять управляющие конструкции в шаблоне html
else:
...
endif;

//Тернарный оператор
$x = 1;
$y = ($x > 5) ? 1 : 2;

//Switch
$a = 3;
switch ($a) {
	case 1: echo 1;
			break;
			
	case "2": echo 2;
			break;
			
	default: echo "none";
}

//Альтернативный вариант switch
$a = 3;
switch (true) {
	case $a == 1: echo 1;
			break;
			
	case $a == "2": echo 2;
			break;
			
	default: echo "none";			
}
//Кодстайл - пустые строки между case

!empty( $x ) // проверка на пустоту - выдает true даже если переменная не существует
!isset( $x ) // проверка на существование
!unset( $x ) //Освободить переменную. Она перестаёт существовать.

//В PHP $x = null означает отсутствие не значения, а самой переменной $x.
$x = null;
isset( $x ); //false


Спрособы формирования страниц
SSR - высокая нагрузка на сервере
	+ лучше работает на старых и слабых устройствах
	+ SEO: лучше доступность для поисковых систем
		
SPA + ниже нагрузка на сервер 
	- выше нагрузка на клиент
	
Для улучшения позиций сайтов в выдаче поисковых систем карточки товаров принято формировать на сервере.

Краткий тег <? использовать не желательно, т.к. это может быть запрещено настройками сервера
или из соображений безопасности.

Кодстайл - в функциях не использовать echo, за исключением функций render.
echo sayHello();
function sayHello()
{
	return "Hello world <br>";
}

!В PHP объявление функции всегда отностится к глобальной области видимости,
даже если функция объявлена внутри другой функции.

!Тело функции имеет локальную область видимости.

!Чтобы объявить глобальную переменную внутри функции необходимо использовать global
global $x;
global желательно не использовать.

!//Значения по умолчанию должны быть только справа, 
//или все параметры должны иметь значения по умолчанию.
function add($arg1, $arg2=0)
{
	return $arg1 + $arg2;
}


function add(...$arg1)
{
	return var_dump( $arg ); //Array
}


!function add(float $arg1, float $arg2=0): float | int //принимает аргументы типа float и
//возвращает результат типа float или int
{
	return $arg1 + $arg2;
}

!Статические переменные, в php это особый вид переменных, которые объявляются при помощи ключевого слова static.

static $foo = 3;

От обычных переменных они отличаются тем что (далее в статье эти пункты будут рассмотрены более подробно):
    могут быть присвоены только константы и константные выражения ( в статическую переменную не может быть присвоен
результат работы какой-либо функции или метода, или вообще что-либо что еще не известно на этапе компиляции)
    время жизни статической переменной не ограничено временем жизни области видимости в которой она была объявлена
    могут быть определены в скрипте лишь однажды
    не уничтожаются до конца выполнения скрипта



!//Запрет на изменение типа переменных
declare( strict_types=1 );

! Переменные переменных
Иногда бывает удобно иметь переменными имена переменных.
То есть, имя переменной, которое может быть определено и изменено динамически.
Обычная переменная определяется примерно таким выражением:

<?php
$a = 'hello';
$$a = 'world';		//объявление переменной $hello, содержащей "world"
echo "$a $$a";		//hello world
echo "$a $hello";	//hello world
?>


!ссылка на переменную — это и есть адрес ячейки памяти.
Для взятия ссылки в PHP используется символ: ‘&’. 

$a = 5;
$b = &$a;
echo $b //выведет 5

Теперь в нашей ячейке, куда мы передали ссылку, находится не какое-либо значение,
а адрес другой ячейки.
И если мы обратимся к переменной, в которой содержится ссылка на другую переменную,
то произойдёт в некотором смысле, redirect(перенаправление), на соответствующую переменную:

$a = 5;
$b = &$a;
$b++;
 
echo $a; //выведет 6


//Вариант №1
$a = 1;
echo inc( $a ); //2
echo $a; 		// 1 - функция inc() не изменила значение переменной $a 
function inc($x)
{
	return ++$x;
}

//Вариант №2 (плохой). Глобальные переменные - это всегда плохо.
$a = 1;
echo inc( $a ); //2
echo $a; 		// 2 - функция inc() изменила значение переменной $a - замыкание?
function inc($x)
{
	global $x;	//Объявляю глобальную переменную внутри функции
	return ++$x;
}

!//Пример использования ссылки на переменную в функции
//Вариант №3 (хороший). Использование ссылки на переменную.
$a = 1;
echo inc( $a ); 	//2
echo $a; 			// 2 - функция inc() изменила значение переменной
function inc(&$x) 	//Создаю ссылку на глобальную переменную внутри функции
{		
	return ++$x;
}

!function_exists() // Проверка функции на существование

!Function Expression и function Declaration анонимные функцииции (присваиваемые переменной)
 в PHP работают как в JavaScript.
 Стрелочные функции поддерживаются PHP с версии 7.4
 $add = fn($x, $y) => $x + $y;
 echo $add( 2, 3 ); // 5
 
 
 !set_time_limit() //Время выполнения скрипта на сервере в сек. (есть в php.ini)
 
 !Пример рекурсивного вызова функции
 function foo( $n ) {
	echo $n--;
	if ( $n > 0 ) foo( $n );
}

 !Факториал с помощью рекурсивного вызова функции
 function factorial ($n) {
 if ( $n === 0 || $n === 1) return 1;
	return $n * factorial ( $n - 1 );
 }
 
 ! Рекурсивные функции применяются для построения меню на сайтах
 
 Домашнее задание №2
 
 1. Использовать rand()
 0 считать положительным числом.

! 5. Динамическая генерация шаблонов.
 Устаревший подход генерации шаблонов допускал include() до 5 уровней вложенности.
Это приводило к появлению "лапшекода".
Современный подход заключается в использовании функции render().

! В PHP существует переменная OUT. В процессе работы скрипта в ней конкатенируются данные,
которые будут выведены в браузер по окончанию работы скрипта.
! В переменной BUFER по умолчанию пусто.
Существует возможность перенаправить вывод данных из переменной OUT в переменную BUFER с помощью функции ob_start().
ob_get_clean() возвращает содержимое с последующей его очисткой.

Лекция №3

!Проверка на чётность (битовые операции).
//00001 1
//00010 2
//00011 3
//00100 4
$i & 2

! for лучше всего подходит для рендеринга
//Альтернативный синтаксис  в HTML

<?php for ($i =0; $i<$n; $i++){ - : чтобы убрать { в начале
<tr>
</tr>
} ?>   = <?php endfor; ?> чтобы убрать } в конце

<?php for ($i =0; $i<$n; $i++): ?>
<tr>
</tr>
<?php endfor; ?>

В PHP все массивы ассоциативны.

В PHP в качестве ключа можно использовать строку
Это рекомендовано.

$arr["title"] = "Главная";
var_dump($arr) // Главная


$translate = [
	'white' => 'белый',
	'red' => 'красный',
	'black' => 'чёрный',
];

echo '<pre>';
var_dump($translate);



for не подходит для перебора разреженных массивов, т.к. выводит null

unset( $arr[i] ) - удаление элемента массива (задаёт значение null)

Для перебора массивов подходит foreach()
foreach ($arr as $key => $item) {} - где $key - index, $item - значение элемента массива

$arr= [
	[1,2],
	[5,7],
]

//Перебор вложенного массива

foreach ($arr as $value){
	foreach ($value as $item){
		var_dump($item)
	}
}

//Функция для вывода меню

function foo($arr) {
	foreach( $arr as $value ) {
		if (is_array($value)) {
			foo($value);
		} else {
			echo $value . ' ';
		var_dump( $value );
	}
}

Домашнее задание

Всё, кроме задания 6, делать в одном файле.

1. if %3

<?php
$i = 0;

while ($i <= 100) {
  if ($i % 3 === 0) echo $i . " ";
  $i++;
}


2. проверка на чётность
0 – ноль.
1 – нечетное число.
2 – четное число.
3 – нечетное число.
…
10 – четное число.

 i/0
использовать битовые операции
вывести как по шаблону в задании

$i=0;
 do {
   if ($i === 0) {
  echo $i . " - ноль." . PHP_EOL;
} else  if ( $i%2 === 0) {
      echo $i . " - четное число." . PHP_EOL;
    } else {
     echo $i . " - нечетное число." . PHP_EOL;
  }
   $i++;
    } while ($i <= 10);


define('EVEN', 1<<1);
$i=0;
 do {
   if ($i === 0) {
  echo $i . " - ноль." . PHP_EOL;
} else  if ( $i & EVEN) {
      echo $i . " - четное число." . PHP_EOL;
    } else {
     echo $i . " - нечетное число." . PHP_EOL;
  }
   $i++;
    } while ($i <= 10);

3. Объявить вложенный массив

Собрать список городов в строку с помощью функции, которая возвращает строку.
запятую в конце заменить на точку, используя документацию php (функция замены строк).

$str = implode(',', $arr) - преобразует массив в строку, на первом месте указывается разделитель.
$arr = explode(',', $str) - преобразует строку в массив с использованием разделителей.

$regions=[
  'Московская область' => ['Москва', 'Зеленоград', 'Клин'],
  'Ленинградская область'=> ['Санкт-Петербург', 'Всеволожск', 'Павловск', 'Кронштадт'],
  'Рязанская область' => ['Рязань', 'Михайлов', 'Скопин', 'Касимов'],
  ];


foreach($regions as $region => $cities){
	printCitiesOfRegions($region, $cities);
}

function printCitiesOfRegions($region, $cities){
	echo $region . ': ' . implode(', ', $cities) . '.' . PHP_EOL;
}


4. Функция транслитерации - используется для преобразования в url.

Найти ф-цию, которая делает это в php
Написать свою функцию

mb_str_split($str) - мультибайтовая функция для работы с кириллицей UTF-8, обычные ф-ции работают с одним байтом

не использовать подмассив

! В PHP строки итерируются как в JS, но только для латинских символов
$str = 'абв';
echo mb_substr($str, 1, 1) - извлекает с первого элемента 1 символ.
!strlen($str) //6 - т.к. исп-ся кириллица.
!mb_strtolower() - приводит строку к нижнему регистру.
Нужно исп-ть for до mb_strlen()

Как передать массив в функцию? глобал, внутр, параметр?

2 if пров на сущ и пров. на заглавность.
Преобразовать к нижнему и сравнить с исх.

mb_strtolower()
mb_strtoupper()


5. Не делать цикл. Исп. str_replace()

6. Создать массив одноуровневый.
Задать в массиве гиперсылку в качестве значения.
В ключе хранить название пункта меню.
Цикл проходит по массиву и генерирует HTML.

Сделать ф-цию для генерации вложенного меню.
вложенный ul должен быть внутри li

7.
echo - конструкция языка;
print() - функция.

echo print(1) // 11 - т.к. первую единицу выводит print, а вторую echo

8. k mb_str()

9. Повторно использовать код предыдущих заданий.

! Суперглобальные массивы


localhost/index.php?name=alex&age=17&id=1
$GET['name'];

!echo $GET['name']; - дыра в безопасности!!!


!Фреймворк
Второй способ формирования шаблона.
<?php
function renderTemplate($page) {
	ob_start()
}

!extract()

Сделать ДЗ на движке.


1. С помощью цикла while вывести все числа в промежутке от 0 до 100, которые делятся на 3 без остатка.



2. С помощью цикла do…while написать функцию для вывода чисел от 0 до 10, чтобы результат выглядел так:
0 – ноль.
1 – нечетное число.
2 – четное число.
3 – нечетное число.
…
10 – четное число.

3. Объявить массив, в котором в качестве ключей будут использоваться названия областей, а в качестве значений – массивы с названиями городов из соответствующей области. Вывести в цикле значения массива, чтобы результат был таким:
Московская область:
Москва, Зеленоград, Клин.
Ленинградская область:
Санкт-Петербург, Всеволожск, Павловск, Кронштадт.
Рязанская область … (названия городов можно найти на maps.yandex.ru) строго соблюдать формат вывода выше, т.е. двоеточие и точка в конце
4. Объявить массив, индексами которого являются буквы русского языка, а значениями – соответствующие латинские буквосочетания (‘а’=> ’a’, ‘б’ => ‘b’, ‘в’ => ‘v’, ‘г’ => ‘g’, …, ‘э’ => ‘e’, ‘ю’ => ‘yu’, ‘я’ => ‘ya’).
Написать функцию транслитерации строк. Она должна учитывать и заглавные буквы.

5. Написать функцию, которая заменяет в строке пробелы на подчеркивания и возвращает видоизмененную строчку. Можно через str_replace
6. В имеющемся шаблоне сайта заменить статичное меню (ul – li) на генерируемое через PHP. Необходимо представить пункты меню как элементы массива и вывести их циклом. Подумать, как можно реализовать меню с вложенными подменю? Попробовать его реализовать. Важное, при желании можно сделать на движке 3. ВАЖНОЕ!
7. *Вывести с помощью цикла for числа от 0 до 9, не используя тело цикла. Выглядеть должно так:
for (…){ // здесь пусто}

8. *Повторить третье задание, но вывести на экран только города, начинающиеся с буквы «К».
9. *Объединить две ранее написанные функции в одну, которая получает строку на русском языке, производит транслитерацию и замену пробелов на подчеркивания (аналогичная задача решается при конструировании url-адресов на основе названия статьи в блогах).

!ctype_upper(mixed $text): bool - Проверяет, все ли символы в переданной строке text являются буквами в верхнем регистре.

!strtoupper(string $string): string - Возвращает строку string, в которой все буквенные символы переведены в верхний регистр.

!ucfirst(string $string): string -Возвращает строку string, в которой первый символ переведён в верхний регистр, если этот символ является буквой.

!str_replace() - str_replace — Заменяет все вхождения строки поиска на строку замены.

!strtr(string $string, string $from, string $to): string - Преобразует заданные символы или заменяет подстроки. Подходит для преобразования текста в URL.
!strtr(string $string, array $replace_pairs): string - альтернативный вариант работает с массивами.

!is_array(mixed $value): bool - Определяет, является ли данная переменная массивом.

! echo vs print

print возвращает всегда единицу (1), echo не возвращает ничего (void). Так как echo не возвращает никаких значений, то и выполняется быстрее, чем print (ровно на величину ресурсов, требуемых на возврат значения. Величина незначительная, но все же);
как следствие, print можно использовать в выражениях, а echo - нет;
echo - не функция, а языковая конструкция. Поэтому использовать скобки необязательно. Более того, если требуется передать несколько аргументов в echo, то скобки использовать нельзя, нужно просто указывать аргументы через запятую;
print также можно использовать без скобок (это также «ненастоящая» функция, языковая конструкция), но передать можно только один аргумент;
у echo есть сокращенная форма записи: <?=$foo?>

Лекция №4

phpStorm Beatyfy ctrl+alt+L

!Включить содержимое одного файла в другой c помощью конструкции языка:
include'путь к папке/имя файла';
./ - корневая папка домена

!$_SERVER — Информация о сервере и среде исполнения

Это 'суперглобальная' или автоматическая глобальная переменная.

Это просто означает, что она доступна во всех контекстах скрипта.

Нет необходимости выполнять global $variable; для доступа к ней внутри метода или функции.



Относительные пути:



!href="./script.php" - относительный путь (рассчитывается относительно точки входа: текущего скрипта (файла)).



href="?action=delete" - тоже относительный путь (будет присоединён к текущему адресу)



! Проблема безопасности - если не контролировать параметры, вводимые пользователем в строку адреса

браузера, то он сможет выйти за пределы localhost и "добраться" до системных файлов.

В целях безопасности сервер не отрабатывает относительные пути, ведущие за пределы localhost.



Windows поддерживает оба варианта разделителя пути: \ и /.

!Linux - только / (прямой слэш).



Абсолютные пути:

!__DIR__ - Директория файла.

Если используется внутри подключаемого файла, то возвращается директория этого файла.

Это эквивалентно вызову dirname(__FILE__).

Возвращаемое имя директории не оканчивается на слэш, за исключением корневой директории.



!dirname( __DIR__ ) - при вызове из корневой папки возвращает путь до папки domains,

при вызове из вложенных папок возвращает "C:/OpenServer/domains/localhost".



!realpath( относительный путь к файлу ) - вычисляет абсолютный путь к файлу из относительного.



В Windows абсолютные пути начинаются с имён дисков.

В Linux - с root, /.

"C:/OpenServer/domains/localhost/1/index.php" - пример абсолютного пути в Windows.



!В php-скриптах:

!$_SERVER['DOCUMENT_ROOT'] - не зависит от точки входа и указывает на корневую папку домена.

var_dump( $_SERVER['DOCUMENT_ROOT'] ) / "C:/OpenServer/domains/localhost/" независимо от точки входа.



'DOCUMENT_ROOT' - Директория корня документов, в которой выполняется текущий скрипт, в точности та, которая указана в конфигурационном файле сервера.



define('ROOT', $_SERVER['DOCUMENT_ROOT'])

include ROOT . "/pathToFile" - будет работать правильно, даже если перенести проект на другой диск или ПК.



!В HTML (браузере):

"http://localhost/pathToFile" - абсолютный путь.

$_SERVER['SERVER_NAME'] - не зависит от точки входа и указывает на корень доменного имени в браузере.

'SERVER_NAME'- Имя хоста, на котором выполняется текущий скрипт.



В HTML:

<img src="<?=HOST?>/pathToFile" alt="">



В HTML использование абсолютных путей не так критично, как в скриптах, но даёт небольшой прирост в скорости.



!include отсутствующего файла вызывает не ошибку, а Warning.

@include - подавляет вывод Warning.

!include используют для подключения неосновного функционала, например рекламных блоков.



!require отсутствующего файла останавливает выполнение скрипта в отличие от include.

!require используют для подключения критически важных блоков (работает чуть медленней, чем include).



!redeclare возникает при попытке повторного объявления функций,

например при повторном подключении библиотек, которые уже подключены другими библиотеками.



!include_once и!require_once file -

позволяют избежать ошибки redeclare, т.к. подключает только файлы, не подключенные ранее.



Чат.

ember.vseverske.ru/chat/



!fopen, fread, fclose - позволяют выполнять операции с файлом.

file_get_contents() - чтение файла целиком (выполняет все три операции поочерёдно).



Если в <form action=""></form> не указать атрибут action, то отправленные данные будут обработаны текущим файлом.



Файлы можно использовать для логирования, кэширования, хранения данных.



$file = fopen("c:\\folder\\resource.txt", "r"); -   Открывает файл только для чтения; помещает указатель в начало файла.

пример 54 мин.



!fputs( $file, $message . PHP_EOL); - Эта функция является псевдонимом: fwrite().

fwrite() записывает содержимое data в файловый поток stream.

'\r\n' - символ перевода каретки на новую строку (не сработал на уроке).



!feof(resource $stream): bool - Проверяет, достигнут ли конец файла.

!fgets(resource $stream, ?int $length = null): string|false - Читает строку из файлового указателя.



Для перезагрузки страницы после отправки данных формы:

пример 1:40



header( "Location: /script.php?status=$message" ); - команда на редирект на другую страницу без чтения текущей.

die(); - точка останова.

В итоге происходит перенаправление браузера на страницу "/script.php",

чтение заголовка, но без чтения HTML,

благодаря точке останова die().

Ошибка 'Header is already send' возникает, если до header() есть какой-то текст
(даже пробел или кодировка UTF-8 with BOM), кроме заключенного в теги <?php ?>.





!Нельзя выводить через echo всё, что вводит в форму пользователь,

т.к. это даёт возможность запускать скрипты, потенциально вредоносные.



$message = strip_tags( $GET['message'] ); - обрезает тэги во входящих данных.





!Загрузка файлов на сервер.

Пример 1:26.



<form method="post" enctype="multipart/form-data" action="index.php">

                <input type="file" name="myfile">

                <input type="submit value="Загрузить">

</form>



multipart/form-data - обязателен для отправки файла.



!$_FILES — Переменные файлов, загруженных по HTTP

var_dump( !$_FILES ) - массив с данными о файлах.



!move_uploaded_file(string $from, string $to): bool

Эта функция проверяет, является ли файл from загруженным на сервер (переданным по протоколу HTTP POST).

Если файл действительно загружен на сервер, он будет перемещён в место, указанное в аргументе to.



if( move_uploaded_file( $FILES['myfile']['tmp_name'], $path))

{

                $message = 'Файл загружен!';

} else {

                  $message =  'Ошибка загрузки!';

}



!Проблема с безопасностью! Пользователь может загрузить на сервер скрипт и выполнить его через адресную строку браузера.

Перед загрузкой файла нужно проверить его на безопасность:

расширение, майнтип?, размер файла.

Пример проверок  1:32.



!basename(string $path, string $suffix = ""): string

При передаче строки с путём к файлу или каталогу, данная функция вернёт последний компонент имени из данного пути.



ДЗ

задание №1

использовать функцию

константу с частью абсолютного пути

!scandir(string $directory, int $sorting_order = SCANDIR_SORT_ASCENDING, ?resource $context = null): array|false

Возвращает массив (array), содержащий имена файлов и каталогов, расположенных по пути, переданном в параметре directory.



Задание 2

include должены быть в самом начале файла.

Использовать библиотеку SimpleImage



На движке

Логику работы сайта хранить в папке engine в отдельных файлах для каждого шаблона.

В целях безопасности (для ограничения доступа извне)

все файлы, к которым должен иметь доступ браузер нужно поместить в каталог public.

В настройках сервера указать папку public в качестве корневой для домена.



Загружаемые файлы проверять на безопасность.

!array_slice(
     array $array,
     int $offset,
     ?int $length = null,
     bool $preserve_keys = false
 ): array
 array_slice() возвращает последовательность элементов массива array, определённую параметрами offset и length.


 Лекция №5 Базы данных

 Недостатки способа хранения данных в файлах:
 1. Нет жёсткой структуры;
 2. Расходуется много памяти;
 3. Нет поиска "из коробки".

 Виды баз данных:
 1. SQL (Structured Query Language) (реляционные - с жёсткой структурой);
 2. NoSQL - нереляционные (например, MongoDB).

 Для создания БД в OpenServer проще всего  использовать phpMyAdmin.

 "Запись" - строка в БД.
 "Поле" - столбец в БД.

 В реляционных БД у каждого поля фиксированный тип данных (в отличие от Excel).

 Для удобства желательно в каждой таблице использовать поле id с уникальным номером.
 В одной базе данных может быть неограниченное количество таблиц.
 Обычно один сайт работает с одной БД.
 Иногда используют несколько БД:
 при высокой нагрузке на сервер;
 если используются несколько серверов.

 25:50 экспорт БД.

 Рекомендованная современная кодировка БД для кириллических сайтов
 utf8mb4_0900_ai_ci
 или
 utf_general_ci (устаревает).

 ci - кириллица.

 Путь к БД: имя диска:\OpenServer\userdata

 Пользователь root имеет доступ ко всем БД - это создаёт проблему безопасности.

 Создание пользователя:
 на главной странице phpMyAdmin вкладка "Учётные записи пользователей", кнопка "Новый".
 Желательно использовать "Имя хоста" "Локальный", чтобы предотвратить удалённый доступ к БД в случае взлома.

Редактирование привилегий:
"Учётные записи пользователей" вкладка "База данных". Выбрать название БД из выпадающего списка.
Для обычного пользователя достаточно привелегий "Данные" и "Структура".
 Права из группы "Администрирование" должны быть только у root.

 information_schema - системная БД (редактировать нельзя!).

 Имена таблиц могут содержать пробелы, но это не рекомендуется, т.к. в запросах имена таблиц придётся брать в
 обратные кавычки: ``.
 Для разделения слов в именах таблиц лучше использовать _.


! Подключение к БД в PHP:
 Может потребоваться убрать комментарий в php.ini напротив mysql_connect.

 mysql_connect(
     string $server = ini_get("mysql.default_host"),
     string $username = ini_get("mysql.default_user"),
     string $password = ini_get("mysql.default_password"),
     bool $new_link = false,
     int $client_flags = 0
 ): resource|false
 Открывает новое соединение с сервером MySQL или использует уже существующее.

 Список параметров ¶
 server
 Сервер MySQL. Может также включать номер порта, например, "hostname:port" или путь к локальному сокету, например, ":/path/to/socket" для локального сервера.

 Если PHP-директива mysql.default_host не определена (по умолчанию), то значением по умолчанию является 'localhost:3306'. В SQL safe mode этот параметр игнорируется и всегда используется значение 'localhost:3306'.

 username
 Имя пользователя. Значение по умолчанию определяется директивой mysql.default_user. В SQL safe mode этот параметр будет проигнорирован и будет использован пользователь, владеющий процессом сервера.

 password
 Пароль. Значение по умолчанию определяется директивой mysql.default_password. В SQL safe mode этот параметр будет проигнорирован и в качестве пароля будет использована пустая строка.

 new_link
 Если второй вызов функции mysql_connect() произошёл с теми же аргументами, то новое соединение не будет установлено. Вместо этого функция вернёт ссылку на уже установленное соединение. Параметр new_link может заставить функцию mysql_connect() открыть ещё одно соединение, даже если соединение с аналогичными параметрами уже открыто. В SQL safe mode этот параметр игнорируется.

 client_flags
 Параметр client_flags должен быть комбинацией из следующих констант: 128 (включает обработку LOAD DATA LOCAL), MYSQL_CLIENT_SSL, MYSQL_CLIENT_COMPRESS, MYSQL_CLIENT_IGNORE_SPACE or MYSQL_CLIENT_INTERACTIVE. Подробнее читайте в разделе Клиентские константы MySQL. В SQL safe mode этот параметр игнорируется.

 Возвращаемые значения ¶
 Возвращает дескриптор соединения с MySQL в случае успешного выполнения или false в случае возникновения ошибки.


 $link = mysqli_connect("localhost:3307", "my_user", "my_password", "world") or die ("Ошибка");

 Здесь по порядку указываются адрес сервера БД, имя пользователя, пароль и имя БД. Поскольку мы
 уже умеем хранить настройки в файле конфигурации, то данные для подключения лучше всего брать
 оттуда.
Иногда, указание IP-адреса вместо localhost позволяет ускорить доступ к локальной БД.
Если порт БД отличается от 3306 (по умолчанию), то его нужно указать: 'localhost:3307'

die ("Ошибка") позволяет избаваться от условия для вывода сообщения в случае ошибки подключения к БД.

В случае ошибок подключения Warning в сообщении выводит путь к файлу с БД, логин и пароль, что опасно,
поэтому Warning в данном случае требуется подавлять.
Для подавления Warning используется @:

 $link = @mysqli_connect("localhost:3307", "my_user", "my_password", "world")
 or die ("Ошибка" . mysqli_connect_error());

!mysqli_connect_error(): ?string - Возвращает сообщение об ошибке последней попытки подключения.


!Закрытие подключения к БД:

mysqli_close($link);

После окончания работы скрипта сервер закроет не только файлы, но и подключения к БД,
и освободит память автоматически.

Закрывать подключение следует в том случае, если для дальнейшей работы скрипта
требуется освободить память.


Запрос к БД:

mysqli_query(mysqli $mysql, string $query, int $result_mode = MYSQLI_STORE_RESULT): mysqli_result|bool
Выполняет запрос query к базе данных.

$result = mysqli_query("SELECT * FROM employee WHERE id > 0");

Для запросов, не подразумевающих получение данных из базы (INSERT, UPDATE, DELETE), функция
возвращает true, в случае успешного выполнения операции, и false – в противном случае.

!mysql_fetch_assoc(resource $result): array
 Возвращает ассоциативный массив, соответствующий полученному ряду и сдвигает вперёд внутренний указатель результата.
 Функция mysql_fetch_assoc() аналогична вызову функции mysql_fetch_array() со вторым необязательным параметром, равным  MYSQL_ASSOC. Функция возвращает только ассоциативный массив, либо false если рядов больше нет.

 Список параметров ¶
 $result - Обрабатываемый результат запроса. Этот результат может быть получен с помощью функции mysql_query().

 $epms = array();
while($row = mysqli_fetch_assoc($result)){
    $epms[] = $row;
}
В переменной $result оказывается результат выборки из базы employee – список всех сотрудников.
Далее мы создаём массив $epms, в который будем добавлять информацию о каждой записи.
Теперь запускаем цикл, который ориентируется на функцию mysqli_fetch_assoc. Она извлекает
очередную строку из выборки данных и возвращает её в переменную $row в виде ассоциативного
массива. Ключами данного массива являются названия столбцов таблицы, а значениями – данные из
конкретной строки. Когда строки закончатся, mysql_fetch_assoc вернёт значение false, и цикл
завершится.
На выходе мы получим двумерный массив $epms с информацией о сотрудниках. В нём будет столько
же элементов, сколько строк вернула база в результате выборки. Каждый его элемент –
ассоциативный массив с информацией об одном сотруднике.
Данная процедура является стандартной. Её достаточно освоить один раз, а затем лишь применять
на практике.

Существуют и другие полезные функции при работе с базой, например:
● mysql_num_rows – число строк, содержащееся в результате выборки данных;
● mysql_affected_rows – число строк, затронутых последним запросом INSERT, UPDATE или DELETE;
● mysql_error – сообщение о последней ошибке, возникшей в ходе запроса;
● mysql_insert_id – id записи, добавленной последним запросом INSERT;
● mysql_close – закрывает соединение с сервером MySql.

Типы данных SQL:
INT - 4 млрд (-2 147 483 648; 2 147 483 648) или (0;4 294 967 295).
VARCHAR - строка переменной длины - используется для короткого текста (можно указать максимальную длину строки и задать значение по умолчанию).
CHAR - строка фиксированной длины (работает быстрее, но даже пустая строка занимает всю длину (пробелы)).
TEXT - для текста большой неограниченной длины (для статей). Задать значение по умолчанию невозможно.

UNSIGNED - для INT без знака (нумерация от 0).
INDEX - PRIMARY - первичный ключ.
A_I - автоинкремент.

Тип таблицы - структура хранения данных.
Желательно использовать InnoDB.
MyISAM устарел (не поддерживает транзакции), хоть и немного быстрее.

В PhpMyAdmin консоль находится во вкладке SQL.

Для импортирования БД необходимо в PhpMyAdmin создать новую базу и через вкладку "Импорт" добавить информацию
из импортируемой базы данных.

!Вывод информации из БД в шаблон:

<?php while ($row = mysqli_fetch_assoc( $result )): ?>
	<a href="/?id=<?= $row[ 'id' ] ?>"><h3><?= $row[ 'title' ] ?> </h3></a>
	<p><?= $row[ 'content' ] ?></p>
	<hr>
<?php endwhile; ?>

или

<? foreach($result as $row): ?>
	<a href="/?id=<?= $row[ 'id' ] ?>"><h3><?= $row[ 'title' ] ?> </h3></a>
	<p><?= $row[ 'content' ] ?></p>
	<hr>
<? endforeach ?>

В случае с foreach вызов mysqli_fetch_assoc не требуется,
т.к. foreach возвращает ассоциативные массивы.

	Вариант 3 - позволяет устранить проблему безопасности:
вывод пути к файлу БД при попытке получить несуществующие данные.
<?php
var_dump( $result );
if ($result -> num_rows !== 0):
	while ($row = mysqli_fetch_assoc( $result )): ?>
		<a href="/?id=<?= $row[ 'id' ] ?>"><h3><?= $row[ 'title' ] ?></h3></a>
		<p><?= $row[ 'content' ] ?></p>
		<hr>
	<?php endwhile; ?>
<?php else : ?>
	<p>Ошибка</p>
<? endif ?>

!Защита от sql-инъекций
$id = (int)$_GET[ 'id' ]; - явное приведение типа к числу не позволит выполнить текстовый запрос

!filesize(string $filename): int|false - Возвращает размер указанного файла, где filename -  путь к файлу.

!pg_insert(
     PgSql\Connection $connection,
     string $table_name,
     array $values,
     int $flags = PGSQL_DML_EXEC
 ): PgSql\Result|string|bool
 pg_insert() вставляет записи из массива values в таблицу table_name.

 !array_map(?callable $callback, array $array, array ...$arrays): array
 Функция array_map() возвращает массив (array), содержащий результаты применения callback-функции к соответствующему элементу array (и arrays, если указано больше массивов), используемого в качестве аргумента callback-функции. Количество параметров, передаваемых callback-функции, должно совпадать с количеством массивов, переданным функции array_map(). Лишние входные массивы игнорируются. Если предоставлено недостаточное количество аргументов, выбрасывается ArgumentCountError.
 Список параметров ¶
 callback callable, применяемая к каждому элементу в каждом массиве.
 null может быть передан в качестве значения callback для выполнения zip операции с несколькими массивами. Если указан только array, array_map() вернёт входной массив.
 array Массив, к которому применяется callback-функция.
 arrays Дополнительные массивы для обработки callback-функцией.

 !Синтаксис query-запросов (кавычки вокруг переменных):
   $result = mysqli_query( $db, "INSERT INTO images (name) VALUES  ('{$item['name']}')" );

  В идеале тут не в цикле запрос выполнять, а собрать в строке, и потом одним insert вставить в БД:

  $images = array_splice(scandir(IMG_BIG), 2);
      mysqli_query($db,"INSERT INTO images(filename) VALUES ('" . implode("'),('", $images) . "')");

 !Пример SQL-запроса на обновление данных в БД:
  mysqli_query( $db, "UPDATE images  SET views = views + 1 WHERE id = {$id}" );

  !// для формирования абсолютного пути относительно папки public
  include $_SERVER[ 'DOCUMENT_ROOT' ] . "/../config/config.php";

  !Чтобы использовать разные файлы стилей в разных шаблонах нужно из  передавать в качестве параметра:

!mysqli_fetch_assoc(mysqli_result $result): array|null|false
 Выбирает одну строку данных из набора результатов и возвращает её в виде ассоциативного массива.
 Каждый последующий вызов этой функции будет возвращать следующую строку в наборе результатов или null, если строк больше нет.

 !Процедурный стиль

  mysqli_fetch_all(mysqli_result $result, int $mode = MYSQLI_NUM): array
  Возвращает двумерный массив всех строк результатов в виде ассоциативного массива, числового массива или обоих.

  Замечание:  До PHP 8.1.0, функция доступна только с mysqlnd.

  Список параметров ¶
  result -  Только для процедурного стиля: объект mysqli_result, полученный с помощью mysqli_query(),
  mysqli_store_result(), mysqli_use_result() или mysqli_stmt_get_result().

  mode - Этот необязательный параметр принимает значение константы, которая указывает на тип массива, в который
  требуется поместить данные.
  Возможные значения параметра: MYSQLI_ASSOC, MYSQLI_NUM или MYSQLI_BOTH.

  Возвращаемые значения - Возвращает массив содержащий ассоциативные или обычные массивы с данными результирующей таблицы.

 !mysqli_affected_rows(mysqli $mysql): int|string
  Возвращает число строк, затронутых последним запросом INSERT, UPDATE, REPLACE или DELETE.
  Работает аналогично mysqli_num_rows() для выражений SELECT.

  !Для SEO требуются ЧПУ.
  Для настройки ЧПУ на сервере Apache используется файл .htacess:

  RewriteEngine on  // Включение режима перенаправления
//Создаются условия:
  RewriteCond %{REQUEST_FILENAME} !-f // если запрашиваемый файл не существует
  RewriteCond %{REQUEST_FILENAME} !-d // если запрашиваемый каталог не существует

  RewriteRule . index.php //перенаправлять запросы на index.php