//Включение xdebug в OpenServer 
В OpenServer открыть /Дополнительно/Конфигурация/PHP7_4
1) В Zend extensions снимаем комментарий со строки zend_extension = xdebug
2) Заменяем
xdebug.mode                      = off
на
xdebug.mode                      = develop

//Объявление констант

define('PI', 3.14); //присваивание значений происходит перед выполением программы
const PI = 3.14; //присваивание значений происходит в процессе выполнения программы
PI = 3.14; //Тоже применяется. Константы принято писать заглавными символами.

При попытке вывода несуществующей константы её название будет преобразовано в строку.

//Существуют предопределённые константы (глобальные?)

__LINE__, __FILE__, __FUNCTION__, __CLASS__, __METHOD__, __DIR__, PHP_VERSION, PHP_OS, PHP_EOL (end of line) 


/ - экранирование спецсимволов
В php бинарный плюс преобразует строку к числу.
(int) - преобразование к целому числу
(float) - преобразование к числу с плавающей точкой

При сложении int и float int будет приведён к float

<?php echo - <?=
`` - избегать использования. Позволяют выполнить код на сервере - это небезопасно!!!!!!!! 
'' - не работает парсинг переменных
"" - работает парсинг переменных
"{$x}" - правильный кодстайл для переменных в тексте

<<< - оператор потокового вывода
<pre> - представляет собой предварительно отформатированный текст, который должен быть представлен точно так, как написано в HTML-файле

//Вывод нескольких строк с помощью тега <pre>
<?php
echo "<pre>";
echo <<<HERE
Несколько
строк
HERE;

//Предпочтительный способ вывода нескольких строк с помощью тега <pre> - текст должен оставаться текстом.
<?php
$x=1;
!echo "<pre>";
?>

Несколько
строк <?= $x ?>

is_null($x) - проверка на null
!error_reporting(E_ALL) - вывод всех ошибок, в т.ч. Warning
error_reporting(E_ALL & !E_NOTICE) - вывод всех ошибок за исключением Warning


$a = (int)1; //явное указание типа переменной
$a = (float)1; //явное указание типа переменной

! rand(1, 3) - выдаёт случайное число из указанного диапазона.

ДЗ:
Первый способ формирования страницы:
Вся логика работы программы располагается вверху файла, php-код до тега html.
В шаблоне HTML выводятся только готовые рассчитанные ранее величины.
Теги должны остаться в шаблоне.

Недостаток - пользователь может увидеть код.

Второй способ формирования страницы - способ активных шаблонов.
!с помощью include
В index.php, в котором содержится вся логика работы сайта, включаем строки include "site.php", содержащие шаблон, в нужных местах.

Третий способ формирования страницы - способ пассивных шаблонов.
В шаблоне переменные представляют из себя обычный текст в фигурных скобках.
<h1>{{ x }}</h1>

$content = file_get_contents("https://ya.ru") //позволяет считать содержимое сайта в переменную.

//В нашем случае нужно считать файл HTML-шаблона в переменную и вывести с помощью echo.
//Перед этим заменим все текстовые вхождения "{{ x }}" на значения переменной $x
!//с помощью функций str_replace() и file_get_contents()
$content = str_replace("{{ x }}", $x, $content)// где $content - всё содержимое шаблона. 
$content = file_get_contents("site.html");
echo $content;

Лекция №2
В ДЗ:
$login = "admin";
$pass = 123;
$auth = false;
Типичная ошибка - в операторе сравнения использовать одно =,
поэтому желательно использовать ===/

//Пример проверки авторизации
if ($login === "admin" && $pass === 123 ) {
	$auth = true;
}

//Логику авторизации можно упростить 
$auth = $login === "admin" && $pass === 123;

//Логика авторизации должна находиться в отдельном файле (auth.php),
//который нужно подключать в шаблон с помощью include.

//Сложно анализировать такой код

<?php if ($auth) {?>
	Добро пожаловать <?= $login ?>!
<?php } else { ?>
	<form action="">
	...
	</form>
<?php } ?>


//Лучше использовать альтернативный синтаксис.
//Альтернативный синтаксис принято использовать в шаблонах html.
//В чистом коде php он преимуществ не даёт.
//Признаком альтернативного синтаксиса является применение : - endif;
//Тогда фигурные скобки не нужны.

<?php if ($auth): ?>
	Добро пожаловать <?= $login ?>!
<?php  else:  ?>
	<form action="">
	...
	</form>
<?php endif; ?>

//Дурной тон - применение goto
a:
echo 1;
goto a;

!Альтернативный синтаксис позволяет заменять управляющие конструкции в шаблоне html
else:
...
endif;

//Тернарный оператор
$x = 1;
$y = ($x > 5) ? 1 : 2;

//Switch
$a = 3;
switch ($a) {
	case 1: echo 1;
			break;
			
	case "2": echo 2;
			break;
			
	default: echo "none";
}

//Альтернативный вариант switch
$a = 3;
switch (true) {
	case $a == 1: echo 1;
			break;
			
	case $a == "2": echo 2;
			break;
			
	default: echo "none";			
}
//Кодстайл - пустые строки между case

!empty( $x ) // проверка на пустоту - выдает true даже если переменная не существует
!isset( $x ) // проверка на существование
!unset( $x ) //Освободить переменную. Она перестаёт существовать.

//В PHP $x = null означает отсутствие не значения, а самой переменной $x.
$x = null;
isset( $x ); //false


Спрособы формирования страниц
SSR - высокая нагрузка на сервере
	+ лучше работает на старых и слабых устройствах
	+ SEO: лучше доступность для поисковых систем
		
SPA + ниже нагрузка на сервер 
	- выше нагрузка на клиент
	
Для улучшения позиций сайтов в выдаче поисковых систем карточки товаров принято формировать на сервере.

Краткий тег <? использовать не желательно, т.к. это может быть запрещено настройками сервера
или из соображений безопасности.

Кодстайл - в функциях не использовать echo, за исключением функций render.
echo sayHello();
function sayHello()
{
	return "Hello world <br>";
}

!В PHP объявление функции всегда отностится к глобальной области видимости,
даже если функция объявлена внутри другой функции.

!Тело функции имеет локальную область видимости.

!Чтобы объявить глобальную переменную внутри функции необходимо использовать global
global $x;
global желательно не использовать.

!//Значения по умолчанию должны быть только справа, 
//или все параметры должны иметь значения по умолчанию.
function add($arg1, $arg2=0)
{
	return $arg1 + $arg2;
}


function add(...$arg1)
{
	return var_dump( $arg ); //Array
}


!function add(float $arg1, float $arg2=0): float | int //принимает аргументы типа float и
//возвращает результат типа float или int
{
	return $arg1 + $arg2;
}

!//Запрет на изменение типа переменных
declare( strict_types=1 );

! Переменные переменных
Иногда бывает удобно иметь переменными имена переменных.
То есть, имя переменной, которое может быть определено и изменено динамически.
Обычная переменная определяется примерно таким выражением:

<?php
$a = 'hello';
$$a = 'world';		//объявление переменной $hello, содержащей "world"
echo "$a $$a";		//hello world
echo "$a $hello";	//hello world
?>


!ссылка на переменную — это и есть адрес ячейки памяти.
Для взятия ссылки в PHP используется символ: ‘&’. 

$a = 5;
$b = &$a;
echo $b //выведет 5

Теперь в нашей ячейке, куда мы передали ссылку, находится не какое-либо значение,
а адрес другой ячейки.
И если мы обратимся к переменной, в которой содержится ссылка на другую переменную,
то произойдёт в некотором смысле, redirect(перенаправление), на соответствующую переменную:

$a = 5;
$b = &$a;
$b++;
 
echo $a; //выведет 6


//Вариант №1
$a = 1;
echo inc( $a ); //2
echo $a; 		// 1 - функция inc() не изменила значение переменной $a 
function inc($x)
{
	return ++$x;
}

//Вариант №2 (плохой). Глобальные переменные - это всегда плохо.
$a = 1;
echo inc( $a ); //2
echo $a; 		// 2 - функция inc() изменила значение переменной $a - замыкание?
function inc($x)
{
	global $x;	//Объявляю глобальную переменную внутри функции
	return ++$x;
}

!//Пример использования ссылки на переменную в функции
//Вариант №3 (хороший). Использование ссылки на переменную.
$a = 1;
echo inc( $a ); 	//2
echo $a; 			// 2 - функция inc() изменила значение переменной
function inc(&$x) 	//Создаю ссылку на глобальную переменную внутри функции
{		
	return ++$x;
}

!function_exists() // Проверка функции на существование

!Function Expression и function Declaration анонимные функцииции (присваиваемые переменной)
 в PHP работают как в JavaScript.
 Стрелочные функции поддерживаются PHP с версии 7.4
 $add = fn($x, $y) => $x + $y;
 echo $add( 2, 3 ); // 5
 
 
 !set_time_limit() //Время выполнения скрипта на сервере в сек. (есть в php.ini)
 
 !Пример рекурсивного вызова функции
 function foo( $n ) {
	echo $n--;
	if ( $n > 0 ) foo( $n );
}

 !Факториал с помощью рекурсивного вызова функции
 function factorial ($n) {
 if ( $n === 0 || $n === 1) return 1;
	return $n * factorial ( $n - 1 );
 }
 
 ! Рекурсивные функции применяются для построения меню на сайтах
 
 Домашнее задание №2
 
 1. Использовать rand()
 0 считать положительным числом.

! 5. Динамическая генерация шаблонов.
 Устаревший подход генерации шаблонов допускал include() до 5 уровней вложенности.
Это приводило к появлению "лапшекода".
Современный подход заключается в использовании функции render().

! В PHP существует переменная OUT. В процессе работы скрипта в ней конкатенируются данные,
которые будут выведены в браузер по окончанию работы скрипта.
! В переменной BUFER по умолчанию пусто.
Существует возможность перенаправить вывод данных из переменной OUT в переменную BUFER с помощью функции ob_start().
ob_get_clean() возвращает содержимое с последующей его очисткой.

Лекция №3

!Проверка на чётность (битовые операции).
//00001 1
//00010 2
//00011 3
//00100 4
$i & 2

! for лучше всего подходит для рендеринга
//Альтернативный синтаксис  в HTML

<?php for ($i =0; $i<$n; $i++){ - : чтобы убрать { в начале
<tr>
</tr>
} ?>   = <?php endfor; ?> чтобы убрать } в конце

<?php for ($i =0; $i<$n; $i++): ?>
<tr>
</tr>
<?php endfor; ?>

В PHP все массивы ассоциативны.

В PHP в качестве ключа можно использовать строку
Это рекомендовано.

$arr["title"] = "Главная";
var_dump($arr) // Главная


$translate = [
	'white' => 'белый',
	'red' => 'красный',
	'black' => 'чёрный',
];

echo '<pre>';
var_dump($translate);



for не подходит для перебора разреженных массивов, т.к. выводит null

unset( $arr[i] ) - удаление элемента массива (задаёт значение null)

Для перебора массивов подходит foreach()
foreach ($arr as $key => $item) {} - где $key - index, $item - значение элемента массива

$arr= [
	[1,2],
	[5,7],
]

//Перебор вложенного массива

foreach ($arr as $value){
	foreach ($value as $item){
		var_dump($item)
	}
}

//Функция для вывода меню

function foo($arr) {
	foreach( $arr as $value ) {
		if (is_array($value)) {
			foo($value);
		} else {
			echo $value . ' ';
		var_dump( $value );
	}
}

Домашнее задание

Всё, кроме задания 6, делать в одном файле.

1. if %3

<?php
$i = 0;

while ($i <= 100) {
  if ($i % 3 === 0) echo $i . " ";
  $i++;
}


2. проверка на чётность
0 – ноль.
1 – нечетное число.
2 – четное число.
3 – нечетное число.
…
10 – четное число.

 i/0
использовать битовые операции
вывести как по шаблону в задании

$i=0;
 do {
   if ($i === 0) {
  echo $i . " - ноль." . PHP_EOL;
} else  if ( $i%2 === 0) {
      echo $i . " - четное число." . PHP_EOL;
    } else {
     echo $i . " - нечетное число." . PHP_EOL;
  }
   $i++;
    } while ($i <= 10);


define('EVEN', 1<<1);
$i=0;
 do {
   if ($i === 0) {
  echo $i . " - ноль." . PHP_EOL;
} else  if ( $i & EVEN) {
      echo $i . " - четное число." . PHP_EOL;
    } else {
     echo $i . " - нечетное число." . PHP_EOL;
  }
   $i++;
    } while ($i <= 10);

3. Объявить вложенный массив

Собрать список городов в строку с помощью функции, которая возвращает строку.
запятую в конце заменить на точку, используя документацию php (функция замены строк).

$str = implode(',', $arr) - преобразует массив в строку, на первом месте указывается разделитель.
$arr = explode(',', $str) - преобразует строку в массив с использованием разделителей.

$regions=[
  'Московская область' => ['Москва', 'Зеленоград', 'Клин'],
  'Ленинградская область'=> ['Санкт-Петербург', 'Всеволожск', 'Павловск', 'Кронштадт'],
  'Рязанская область' => ['Рязань', 'Михайлов', 'Скопин', 'Касимов'],
  ];


foreach($regions as $region => $cities){
	printCitiesOfRegions($region, $cities);
}

function printCitiesOfRegions($region, $cities){
	echo $region . ': ' . implode(', ', $cities) . '.' . PHP_EOL;
}


4. Функция транслитерации - используется для преобразования в url.

Найти ф-цию, которая делает это в php
Написать свою функцию

mb_str_split($str) - мультибайтовая функция для работы с кириллицей UTF-8, обычные ф-ции работают с одним байтом

не использовать подмассив

! В PHP строки итерируются как в JS, но только для латинских символов
$str = 'абв';
echo mb_substr($str, 1, 1) - извлекает с первого элемента 1 символ.
!strlen($str) //6 - т.к. исп-ся кириллица.
!mb_strtolower() - приводит строку к нижнему регистру.
Нужно исп-ть for до mb_strlen()

Как передать массив в функцию? глобал, внутр, параметр?

2 if пров на сущ и пров. на заглавность.
Преобразовать к нижнему и сравнить с исх.

mb_strtolower()
mb_strtoupper()


5. Не делать цикл. Исп. str_replace()

6. Создать массив одноуровневый.
Задать в массиве гиперсылку в качестве значения.
В ключе хранить название пункта меню.
Цикл проходит по массиву и генерирует HTML.

Сделать ф-цию для генерации вложенного меню.
вложенный ul должен быть внутри li

7.
echo - конструкция языка;
print() - функция.

echo print(1) // 11 - т.к. первую единицу выводит print, а вторую echo

8. k mb_str()

9. Повторно использовать код предыдущих заданий.

! Суперглобальные массивы


localhost/index.php?name=alex&age=17&id=1
$GET['name'];

!echo $GET['name']; - дыра в безопасности!!!


!Фреймворк
Второй способ формирования шаблона.
<?php
function renderTemplate($page) {
	ob_start()
}

!extract()

Сделать ДЗ на движке.


1. С помощью цикла while вывести все числа в промежутке от 0 до 100, которые делятся на 3 без остатка.



2. С помощью цикла do…while написать функцию для вывода чисел от 0 до 10, чтобы результат выглядел так:
0 – ноль.
1 – нечетное число.
2 – четное число.
3 – нечетное число.
…
10 – четное число.

3. Объявить массив, в котором в качестве ключей будут использоваться названия областей, а в качестве значений – массивы с названиями городов из соответствующей области. Вывести в цикле значения массива, чтобы результат был таким:
Московская область:
Москва, Зеленоград, Клин.
Ленинградская область:
Санкт-Петербург, Всеволожск, Павловск, Кронштадт.
Рязанская область … (названия городов можно найти на maps.yandex.ru) строго соблюдать формат вывода выше, т.е. двоеточие и точка в конце
4. Объявить массив, индексами которого являются буквы русского языка, а значениями – соответствующие латинские буквосочетания (‘а’=> ’a’, ‘б’ => ‘b’, ‘в’ => ‘v’, ‘г’ => ‘g’, …, ‘э’ => ‘e’, ‘ю’ => ‘yu’, ‘я’ => ‘ya’).
Написать функцию транслитерации строк. Она должна учитывать и заглавные буквы.

5. Написать функцию, которая заменяет в строке пробелы на подчеркивания и возвращает видоизмененную строчку. Можно через str_replace
6. В имеющемся шаблоне сайта заменить статичное меню (ul – li) на генерируемое через PHP. Необходимо представить пункты меню как элементы массива и вывести их циклом. Подумать, как можно реализовать меню с вложенными подменю? Попробовать его реализовать. Важное, при желании можно сделать на движке 3. ВАЖНОЕ!
7. *Вывести с помощью цикла for числа от 0 до 9, не используя тело цикла. Выглядеть должно так:
for (…){ // здесь пусто}

8. *Повторить третье задание, но вывести на экран только города, начинающиеся с буквы «К».
9. *Объединить две ранее написанные функции в одну, которая получает строку на русском языке, производит транслитерацию и замену пробелов на подчеркивания (аналогичная задача решается при конструировании url-адресов на основе названия статьи в блогах).

!ctype_upper(mixed $text): bool - Проверяет, все ли символы в переданной строке text являются буквами в верхнем регистре.

!strtoupper(string $string): string - Возвращает строку string, в которой все буквенные символы переведены в верхний регистр.

!ucfirst(string $string): string -Возвращает строку string, в которой первый символ переведён в верхний регистр, если этот символ является буквой.

!str_replace() - str_replace — Заменяет все вхождения строки поиска на строку замены.

!is_array(mixed $value): bool - Определяет, является ли данная переменная массивом.

! echo vs print

print возвращает всегда единицу (1), echo не возвращает ничего (void). Так как echo не возвращает никаких значений, то и выполняется быстрее, чем print (ровно на величину ресурсов, требуемых на возврат значения. Величина незначительная, но все же);
как следствие, print можно использовать в выражениях, а echo - нет;
echo - не функция, а языковая конструкция. Поэтому использовать скобки необязательно. Более того, если требуется передать несколько аргументов в echo, то скобки использовать нельзя, нужно просто указывать аргументы через запятую;
print также можно использовать без скобок (это также «ненастоящая» функция, языковая конструкция), но передать можно только один аргумент;
у echo есть сокращенная форма записи: <?=$foo?>